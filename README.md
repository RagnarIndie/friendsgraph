#FriendsGraph API

##Требования
* [Composer](https://getcomposer.org/download/)
* PHP 5.6
* [Neo4j Graph Database - CE](http://neo4j.com/download/)

##Установка
1. `git clone https://github.com/RagnarIndie/friendsgraph.git` в необходимую директорию;
2. Настроить вебрут виртуал хоста на директорию friendsgraph/web, убедиться что mod_rewrite включен;
3. Установить Neo4j CE для выбранной платформы;
4. В конфигурационном файле приложения friendsgraph/config/dev.json прописать корректные параметры подключения к Neo4j, в секции db;
5. В корне директории friendsgraph выполнить `composer install`. Для установки всех необходимых компонентов, возможно, потребуется
ввести github-токен;

##Начало работы
*Для удобства, в инструкциях будет использоваться домен* `friendsgraph.dev`

Все доступные URI и HTTP-методы для использования RESTful API можно увидеть, открыв заглавную страницу приложения - http://friendsgraph.dev/

Для начала работы, необходимо сгенерировать тестовые ноды (пользователей) в БД. Для этого необходимо просто открыть след. URL - http://friendsgraph.dev/service/generate

После того как скрипт отработает, в БД будет доступно 200 тестовых пользователей без каких либо связей между ними.
При успешном выполнении операции, приложение должно вернуть ответ 200 OK в формате application/json:
```
{
    success: true
}
```
**Внимание! Повторный запуск данного скрипта приведет к повторной вставке пользователей с теми же именами**

После того как пользователи были сгенерированы, их полный список можно получить, используя RESTful API:
`GET http://friendsgraph.dev/api/0.1/users`

##Структура RESTful интерфейса
* Дефолтный API-basepath для RESTful интерфейса - /api/0.1
* За API-basepath следуют сущности: коллекции и русурсы.
* В приложении реализовано 3 вида коллекций ресурсов:
    1. **/users** - коллекция пользователей. Для доступа к ресурсу данной коллекции (объекту пользователя), необходимо указать user_id
    в URI. Например, /users/c0fd5c
    2. **/users/{user_id}/requests** - коллекция входящих/исходящих запросов на добавление в друзья. Для доступа к определенному запросу
    в scope пользователя, необходимо указать request_id в URI. Например, /users/c0fd5c/requests/d5c1dd3af63caf4
    3. **/users/{user_id}/friends** - коллекция друзей пользователя. Например, /users/c0fd5c/friends
* Операции с ресурсами реализуются через использование HTTP verbs (GET, PUT, POST, DELETE):
    * **GET /users** - полный список пользователей без связей. Формат ответа - json массив объектов User.
    Формат User:
    ```
    {
        id: "ac58fe65",
        name: "Fairy Tetzlaff",
        age: "55",
        countryCode: "BR",
        country: "Brazil"
    }
    ```
    * **POST /users** - создание нового пользователя. В теле запроса неоходимо отправить такие поля: name, age, country, countryCode
    В ответ приложение вернет HTTP статус (200|404), статус и id созданного пользователя в формате application/json:
    ```
    {
        success: true|false,
        id: {user_id|null}
    }
    ```
    * **GET /users/{user_id}** - возвращает один объект типа User (в стандартном формате User)
    * **PUT /users/{user_id}** - обновление полей существующего пользователя. В теле запроса необходимо отправить все поля name, age, country, countryCode
    (даже если их значения не требуют обновления)
    * **DELETE /users/{user_id}** - удаляет существующего пользователя

    * **GET /users/{user_id}/friends** - возвращает массив друзей указанного пользователя. Формат объекта друга - такой же как и у User
    (по сути, это и является массив объектов User). Здесь, так же, можно получить друзей друзей (исключая ближайших друзей первого порядка).
    Для того что-бы получить массив друзей друзей n-порядка, к URI необходимо добавить дополнительный запрос - ?level=n,
    где n - уровень вложенности. Например, /users/{user_id}/friends?level=2 - ближайшие друзья друзей пользователя. 3 - друзья друзей друзей и т.д.
    * **DELETE /users/{user_id}/friends/{friend_id}** - удалить друга из списка друзей выбранного пользователя

    * **GET /users/{user_id}/requests** - возвращает массив именованных массивов входящих (in) и исходящих (out) запросов
    на добавление в друзья. Каждый запрос является ребром графа связей пользователей (тип :REQUESTS_FRIENDSHIP). Данные связи
    хранят дополнительную информацию о запросе, необходимую для последующего связывания пользователей.
    Формат данных запроса:
    ```
    {
        id: {id}, #id запрос
        from: {from_user_id}, #id пользователя который отправил запрос
        to: {to_user_id}, #id пользователя который должен получить запрос
        created: {created} #unix timestamp метка - время создания запроса
    }
    ```
    * **POST /users/{user_id}/requests** - создание нового запроса на добавление в друзья. Параметр URI user_id - отправитель запроса.
    В теле запроса необходимо отправить id пользователя, которому данный запрос адресован в поле to_user_id. В ответ приложение вернет
    HTTP статус (200|404), статус и id созданного запроса в формате application/json:
    ```
    {
        success: true|false,
        id: {request_id|null}
    }
    ```
    * **GET /users/{user_id}/requests/{request_id}** - возвращает объект запроса на добавление в друзья по его id
    в формате метаданных ребра графа типа :REQUESTS_FRIENDSHIP
    * **PUT /users/{user_id}/requests/{request_id}** - подтвердить входящий запрос на добавление в друзья по request_id.
    Данное действие создаст двунаправленную связь между пользователями (from и to из метаданных :REQUESTS_FRIENDSHIP) - ребро
    типа (from)<-[:FRIEND_OF]->(to) и удалит оригинальный запрос на добавление в друзья (from)->[:REQUESTS_FRIENDSHIP]->(to)
    * **DELETE /users/{user_id}/requests/{request_id}** - отклонить запрос на добавление в друзья
